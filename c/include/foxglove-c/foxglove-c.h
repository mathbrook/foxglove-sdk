/*
 * NOTE: This file is autogenerated by cbindgen.
 *
 * Foxglove SDK
 * https://github.com/foxglove/foxglove-sdk
 */


#ifndef FOXGLOVE_H
#define FOXGLOVE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifndef FOXGLOVE_NONNULL
#define FOXGLOVE_NONNULL
#endif


/**
 * Allow clients to advertise channels to send data messages to the server.
 */
#define FOXGLOVE_SERVER_CAPABILITY_CLIENT_PUBLISH (1 << 0)

/**
 * Allow clients to subscribe and make connection graph updates
 */
#define FOXGLOVE_SERVER_CAPABILITY_CONNECTION_GRAPH (1 << 1)

/**
 * Allow clients to get & set parameters.
 */
#define FOXGLOVE_SERVER_CAPABILITY_PARAMETERS (1 << 2)

/**
 * Inform clients about the latest server time.
 *
 * This allows accelerated, slowed, or stepped control over the progress of time. If the
 * server publishes time data, then timestamps of published messages must originate from the
 * same time source.
 */
#define FOXGLOVE_SERVER_CAPABILITY_TIME (1 << 3)

/**
 * Allow clients to call services.
 */
#define FOXGLOVE_SERVER_CAPABILITY_SERVICES (1 << 4)

/**
 * Allow clients to request assets. If you supply an asset handler to the server, this capability
 * will be advertised automatically.
 */
#define FOXGLOVE_SERVER_CAPABILITY_ASSETS (1 << 5)

enum foxglove_error
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  FOXGLOVE_ERROR_OK,
  FOXGLOVE_ERROR_UNSPECIFIED,
  FOXGLOVE_ERROR_VALUE_ERROR,
  FOXGLOVE_ERROR_UTF8_ERROR,
  FOXGLOVE_ERROR_SINK_CLOSED,
  FOXGLOVE_ERROR_SCHEMA_REQUIRED,
  FOXGLOVE_ERROR_MESSAGE_ENCODING_REQUIRED,
  FOXGLOVE_ERROR_SERVER_ALREADY_STARTED,
  FOXGLOVE_ERROR_BIND,
  FOXGLOVE_ERROR_DUPLICATE_SERVICE,
  FOXGLOVE_ERROR_MISSING_REQUEST_ENCODING,
  FOXGLOVE_ERROR_SERVICES_NOT_SUPPORTED,
  FOXGLOVE_ERROR_CONNECTION_GRAPH_NOT_SUPPORTED,
  FOXGLOVE_ERROR_IO_ERROR,
  FOXGLOVE_ERROR_MCAP_ERROR,
  FOXGLOVE_ERROR_BUFFER_TOO_SHORT,
  FOXGLOVE_ERROR_BASE64_DECODE_ERROR,
};
#ifndef __cplusplus
typedef uint8_t foxglove_error;
#endif // __cplusplus

enum foxglove_log_level
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  FOXGLOVE_LOG_LEVEL_OFF = 0,
  FOXGLOVE_LOG_LEVEL_DEBUG = 1,
  FOXGLOVE_LOG_LEVEL_INFO = 2,
  FOXGLOVE_LOG_LEVEL_WARN = 3,
  FOXGLOVE_LOG_LEVEL_ERROR = 4,
};
#ifndef __cplusplus
typedef uint8_t foxglove_log_level;
#endif // __cplusplus

enum foxglove_mcap_compression
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  FOXGLOVE_MCAP_COMPRESSION_NONE,
  FOXGLOVE_MCAP_COMPRESSION_ZSTD,
  FOXGLOVE_MCAP_COMPRESSION_LZ4,
};
#ifndef __cplusplus
typedef uint8_t foxglove_mcap_compression;
#endif // __cplusplus

/**
 * A parameter type.
 *
 * This enum is used to disambiguate `foxglove_parameter` values, in situations where the wire
 * representation is ambiguous.
 */
enum foxglove_parameter_type
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  /**
   * The parameter value can be inferred from the inner parameter value tag.
   */
  FOXGLOVE_PARAMETER_TYPE_NONE,
  /**
   * An array of bytes.
   */
  FOXGLOVE_PARAMETER_TYPE_BYTE_ARRAY,
  /**
   * A decimal or integer value that can be represented as a `float64`.
   */
  FOXGLOVE_PARAMETER_TYPE_FLOAT64,
  /**
   * An array of decimal or integer values that can be represented as `float64`s.
   */
  FOXGLOVE_PARAMETER_TYPE_FLOAT64_ARRAY,
};
#ifndef __cplusplus
typedef uint8_t foxglove_parameter_type;
#endif // __cplusplus

/**
 * A variant discriminator for `FoxgloveParameterValueData`.
 */
enum foxglove_parameter_value_tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  FOXGLOVE_PARAMETER_VALUE_TAG_NUMBER,
  FOXGLOVE_PARAMETER_VALUE_TAG_BOOLEAN,
  FOXGLOVE_PARAMETER_VALUE_TAG_STRING,
  FOXGLOVE_PARAMETER_VALUE_TAG_ARRAY,
  FOXGLOVE_PARAMETER_VALUE_TAG_DICT,
};
#ifndef __cplusplus
typedef uint8_t foxglove_parameter_value_tag;
#endif // __cplusplus

typedef struct foxglove_channel foxglove_channel;

typedef struct foxglove_connection_graph foxglove_connection_graph;

typedef struct foxglove_context foxglove_context;

typedef struct foxglove_fetch_asset_responder foxglove_fetch_asset_responder;

typedef struct foxglove_mcap_writer foxglove_mcap_writer;

typedef struct foxglove_service foxglove_service;

typedef struct foxglove_service_responder foxglove_service_responder;

typedef struct foxglove_websocket_server foxglove_websocket_server;

/**
 * A string with associated length.
 */
typedef struct foxglove_string {
  /**
   * Pointer to valid UTF-8 data
   */
  const char *data;
  /**
   * Number of bytes in the string
   */
  size_t len;
} foxglove_string;

typedef struct foxglove_client_channel {
  uint32_t id;
  const char *topic;
  const char *encoding;
  const char *schema_name;
  const char *schema_encoding;
  const void *schema;
  size_t schema_len;
} foxglove_client_channel;

/**
 * An array of parameter values.
 *
 * Constructed with `foxglove_parameter_value_array_create`.
 */
typedef struct foxglove_parameter_value_array {
  /**
   * A pointer to the array of parameter values.
   */
  const struct foxglove_parameter_value *values;
  /**
   * Number of elements in the array.
   */
  size_t len;
  /**
   * Capacity of the array.
   */
  size_t capacity;
} foxglove_parameter_value_array;

/**
 * An dictionary entry for a parameter value.
 *
 * Constructed implicitly with `foxglove_parameter_value_dict_insert`.
 */
typedef struct foxglove_parameter_value_dict_entry {
  /**
   * The dictionary entry's key.
   */
  struct foxglove_string key;
  /**
   * The dictionary entry's value.
   */
  const struct foxglove_parameter_value *value;
} foxglove_parameter_value_dict_entry;

/**
 * An dictionary of parameter values.
 *
 * Constructed with `foxglove_parameter_value_dict_create`.
 */
typedef struct foxglove_parameter_value_dict {
  /**
   * A pointer to the array of dictionary entries.
   */
  const struct foxglove_parameter_value_dict_entry *entries;
  /**
   * Number of elements in the dictionary.
   */
  size_t len;
  /**
   * Capacity of the dictionary.
   */
  size_t capacity;
} foxglove_parameter_value_dict;

/**
 * Storage for `FoxgloveParameterValue`.
 */
typedef union foxglove_parameter_value_data {
  double number;
  bool boolean;
  struct foxglove_string string;
  struct foxglove_parameter_value_array array;
  struct foxglove_parameter_value_dict dict;
} foxglove_parameter_value_data;

/**
 * A websocket parameter value.
 *
 * Constructed with `foxglove_parameter_value_create_*`.
 */
typedef struct foxglove_parameter_value {
  /**
   * A variant discriminator for the `data` union.
   */
  foxglove_parameter_value_tag tag;
  /**
   * Storage for the value's data.
   */
  union foxglove_parameter_value_data data;
} foxglove_parameter_value;

/**
 * A websocket parameter.
 *
 * Constructed with `foxglove_parameter_create`.
 */
typedef struct foxglove_parameter {
  /**
   * Parameter name.
   */
  struct foxglove_string name;
  /**
   * Parameter type.
   */
  foxglove_parameter_type type;
  /**
   * Parameter value.
   */
  const struct foxglove_parameter_value *value;
} foxglove_parameter;

/**
 * An array of websocket parameters.
 *
 * Constructed with `foxglove_parameter_array_create`.
 */
typedef struct foxglove_parameter_array {
  /**
   * Pointer to array of parameters.
   */
  const struct foxglove_parameter *parameters;
  /**
   * Number of valid elements in the array.
   */
  size_t len;
  /**
   * Capacity of the array.
   */
  size_t capacity;
} foxglove_parameter_array;

typedef struct foxglove_server_callbacks {
  /**
   * A user-defined value that will be passed to callback functions
   */
  const void *context;
  void (*on_subscribe)(uint64_t channel_id, const void *context);
  void (*on_unsubscribe)(uint64_t channel_id, const void *context);
  void (*on_client_advertise)(uint32_t client_id,
                              const struct foxglove_client_channel *channel,
                              const void *context);
  void (*on_message_data)(uint32_t client_id,
                          uint32_t client_channel_id,
                          const uint8_t *payload,
                          size_t payload_len,
                          const void *context);
  void (*on_client_unadvertise)(uint32_t client_id, uint32_t client_channel_id, const void *context);
  /**
   * Callback invoked when a client requests parameters.
   *
   * Requires `FOXGLOVE_CAPABILITY_PARAMETERS`.
   *
   * The `request_id` argument may be NULL.
   *
   * The `param_names` argument is guaranteed to be non-NULL. These arguments point to buffers
   * that are valid and immutable for the duration of the call. If the callback wishes to store
   * these values, they must be copied out.
   *
   * This function should return the named parameters, or all parameters if `param_names` is
   * empty. The return value must be allocated with `foxglove_parameter_array_create`. Ownership
   * of this value is transfered to the callee, who is responsible for freeing it. A NULL return
   * value is treated as an empty array.
   */
  struct foxglove_parameter_array *(*on_get_parameters)(const void *context,
                                                        uint32_t client_id,
                                                        const struct foxglove_string *request_id,
                                                        const struct foxglove_string *param_names,
                                                        size_t param_names_len);
  /**
   * Callback invoked when a client sets parameters.
   *
   * Requires `FOXGLOVE_CAPABILITY_PARAMETERS`.
   *
   * The `request_id` argument may be NULL.
   *
   * The `params` argument is guaranteed to be non-NULL. These arguments point to buffers that
   * are valid and immutable for the duration of the call. If the callback wishes to store these
   * values, they must be copied out.
   *
   * This function should return the updated parameters. The return value must be allocated with
   * `foxglove_parameter_array_create`. Ownership of this value is transfered to the callee, who
   * is responsible for freeing it. A NULL return value is treated as an empty array.
   *
   * All clients subscribed to updates for the returned parameters will be notified.
   */
  struct foxglove_parameter_array *(*on_set_parameters)(const void *context,
                                                        uint32_t client_id,
                                                        const struct foxglove_string *request_id,
                                                        const struct foxglove_parameter_array *params);
  /**
   * Callback invoked when a client subscribes to the named parameters for the first time.
   *
   * Requires `FOXGLOVE_CAPABILITY_PARAMETERS`.
   *
   * The `param_names` argument is guaranteed to be non-NULL. This argument points to buffers
   * that are valid and immutable for the duration of the call. If the callback wishes to store
   * these values, they must be copied out.
   */
  void (*on_parameters_subscribe)(const void *context,
                                  const struct foxglove_string *param_names,
                                  size_t param_names_len);
  /**
   * Callback invoked when the last client unsubscribes from the named parameters.
   *
   * Requires `FOXGLOVE_CAPABILITY_PARAMETERS`.
   *
   * The `param_names` argument is guaranteed to be non-NULL. This argument points to buffers
   * that are valid and immutable for the duration of the call. If the callback wishes to store
   * these values, they must be copied out.
   */
  void (*on_parameters_unsubscribe)(const void *context,
                                    const struct foxglove_string *param_names,
                                    size_t param_names_len);
  void (*on_connection_graph_subscribe)(const void *context);
  void (*on_connection_graph_unsubscribe)(const void *context);
} foxglove_server_callbacks;

typedef uint8_t foxglove_server_capability;

typedef struct foxglove_server_options {
  /**
   * `context` can be null, or a valid pointer to a context created via `foxglove_context_new`.
   * If it's null, the server will be created with the default context.
   */
  const struct foxglove_context *context;
  struct foxglove_string name;
  struct foxglove_string host;
  uint16_t port;
  const struct foxglove_server_callbacks *callbacks;
  foxglove_server_capability capabilities;
  const struct foxglove_string *supported_encodings;
  size_t supported_encodings_count;
  /**
   * Context provided to the `fetch_asset` callback.
   */
  const void *fetch_asset_context;
  /**
   * Fetch an asset with the given URI and return it via the responder.
   *
   * This method is invoked from the client's main poll loop and must not block. If blocking or
   * long-running behavior is required, the implementation should return immediately and handle
   * the request asynchronously.
   *
   * The `uri` provided to the callback is only valid for the duration of the callback. If the
   * implementation wishes to retain its data for a longer lifetime, it must copy data out of
   * it.
   *
   * The `responder` provided to the callback represents an unfulfilled response. The
   * implementation must eventually call either `foxglove_fetch_asset_respond_ok` or
   * `foxglove_fetch_asset_respond_error`, exactly once, in order to complete the request. It is
   * safe to invoke these completion functions synchronously from the context of the callback.
   *
   * # Safety
   * - If provided, the handler callback must be a pointer to the fetch asset callback function,
   *   and must remain valid until the server is stopped.
   */
  void (*fetch_asset)(const void *context,
                      const struct foxglove_string *uri,
                      struct foxglove_fetch_asset_responder *responder);
} foxglove_server_options;

typedef struct foxglove_mcap_options {
  /**
   * `context` can be null, or a valid pointer to a context created via `foxglove_context_new`.
   * If it's null, the mcap file will be created with the default context.
   */
  const struct foxglove_context *context;
  struct foxglove_string path;
  bool truncate;
  foxglove_mcap_compression compression;
  struct foxglove_string profile;
  /**
   * chunk_size of 0 is treated as if it was omitted (None)
   */
  uint64_t chunk_size;
  bool use_chunks;
  bool disable_seeking;
  bool emit_statistics;
  bool emit_summary_offsets;
  bool emit_message_indexes;
  bool emit_chunk_indexes;
  bool emit_attachment_indexes;
  bool emit_metadata_indexes;
  bool repeat_channels;
  bool repeat_schemas;
} foxglove_mcap_options;

typedef struct foxglove_schema {
  struct foxglove_string name;
  struct foxglove_string encoding;
  const uint8_t *data;
  size_t data_len;
} foxglove_schema;

/**
 * A byte array with associated length.
 */
typedef struct foxglove_bytes {
  /**
   * Pointer to data
   */
  const uint8_t *data;
  /**
   * Number of bytes
   */
  size_t len;
} foxglove_bytes;

/**
 * A schema describing either a websocket service request or response.
 */
typedef struct foxglove_service_message_schema {
  /**
   * The message encoding.
   */
  struct foxglove_string encoding;
  /**
   * The message schema.
   */
  struct foxglove_schema schema;
} foxglove_service_message_schema;

/**
 * A websocket service schema.
 */
typedef struct foxglove_service_schema {
  /**
   * Service schema name.
   */
  struct foxglove_string name;
  /**
   * Optional request message schema.
   */
  const struct foxglove_service_message_schema *request;
  /**
   * Optional response message schema.
   */
  const struct foxglove_service_message_schema *response;
} foxglove_service_schema;

/**
 * A websocket service request message.
 */
typedef struct foxglove_service_request {
  /**
   * The service name.
   */
  struct foxglove_string service_name;
  /**
   * The client ID.
   */
  uint32_t client_id;
  /**
   * The call ID that uniquely identifies this request for this client.
   */
  uint32_t call_id;
  /**
   * The request encoding.
   */
  struct foxglove_string encoding;
  /**
   * The request payload.
   */
  struct foxglove_bytes payload;
} foxglove_service_request;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create and start a server.
 *
 * Resources must later be freed by calling `foxglove_server_stop`.
 *
 * `port` may be 0, in which case an available port will be automatically selected.
 *
 * Returns 0 on success, or returns a FoxgloveError code on error.
 *
 * # Safety
 * If `name` is supplied in options, it must contain valid UTF8.
 * If `host` is supplied in options, it must contain valid UTF8.
 * If `supported_encodings` is supplied in options, all `supported_encodings` must contain valid
 * UTF8, and `supported_encodings` must have length equal to `supported_encodings_count`.
 */
foxglove_error foxglove_server_start(const struct foxglove_server_options *FOXGLOVE_NONNULL options,
                                     struct foxglove_websocket_server **server);

/**
 * Adds a service to the server.
 *
 * # Safety
 * - `server` must be a valid pointer to a server started with `foxglove_server_start`.
 * - `service` must be a valid pointer to a service allocated by `foxglove_service_create`. This
 *   value is moved into this function, and must not be accessed afterwards.
 */
foxglove_error foxglove_server_add_service(const struct foxglove_websocket_server *server,
                                           struct foxglove_service *service);

/**
 * Removes a service from the server.
 *
 * # Safety
 * - `server` must be a valid pointer to a server started with `foxglove_server_start`.
 * - `service_name` must be a valid pointer to a UTF-8 string.
 */
foxglove_error foxglove_server_remove_service(const struct foxglove_websocket_server *server,
                                              struct foxglove_string service_name);

/**
 * Get the port on which the server is listening.
 */
uint16_t foxglove_server_get_port(struct foxglove_websocket_server *server);

/**
 * Stop and shut down `server` and free the resources associated with it.
 */
foxglove_error foxglove_server_stop(struct foxglove_websocket_server *server);

/**
 * Publish parameter values to all subscribed clients.
 *
 * # Safety
 * - `params` must be a valid parameter to a value allocated by `foxglove_parameter_array_create`.
 *   This value is moved into this function, and must not be accessed afterwards.
 */
foxglove_error foxglove_server_publish_parameter_values(struct foxglove_websocket_server *server,
                                                        struct foxglove_parameter_array *params);

/**
 * Publish a connection graph to the server.
 */
foxglove_error foxglove_server_publish_connection_graph(struct foxglove_websocket_server *server,
                                                        struct foxglove_connection_graph *graph);

/**
 * Create or open an MCAP file for writing.
 * Resources must later be freed with `foxglove_mcap_close`.
 *
 * Returns 0 on success, or returns a FoxgloveError code on error.
 *
 * # Safety
 * `path` and `profile` must contain valid UTF8. If `context` is non-null,
 * it must have been created by `foxglove_context_new`.
 */
foxglove_error foxglove_mcap_open(const struct foxglove_mcap_options *FOXGLOVE_NONNULL options,
                                  struct foxglove_mcap_writer **writer);

/**
 * Close an MCAP file writer created via `foxglove_mcap_open`.
 *
 * Returns 0 on success, or returns a FoxgloveError code on error.
 *
 * # Safety
 * `writer` must be a valid pointer to a `FoxgloveMcapWriter` created via `foxglove_mcap_open`.
 */
foxglove_error foxglove_mcap_close(struct foxglove_mcap_writer *writer);

/**
 * Create a new channel. The channel must later be freed with `foxglove_channel_free`.
 *
 * Returns 0 on success, or returns a FoxgloveError code on error.
 *
 * # Safety
 * `topic` and `message_encoding` must contain valid UTF8.
 * `schema` is an optional pointer to a schema. The schema and the data it points to
 * need only remain alive for the duration of this function call (they will be copied).
 * `context` can be null, or a valid pointer to a context created via `foxglove_context_new`.
 * `channel` is an out **FoxgloveChannel pointer, which will be set to the created channel
 * if the function returns success.
 */
foxglove_error foxglove_channel_create(struct foxglove_string topic,
                                       struct foxglove_string message_encoding,
                                       const struct foxglove_schema *schema,
                                       const struct foxglove_context *context,
                                       const struct foxglove_channel **channel);

/**
 * Free a channel created via `foxglove_channel_create`.
 *
 * # Safety
 * `channel` must be a valid pointer to a `foxglove_channel` created via `foxglove_channel_create`.
 * If channel is null, this does nothing.
 */
void foxglove_channel_free(const struct foxglove_channel *channel);

/**
 * Get the ID of a channel.
 *
 * # Safety
 * `channel` must be a valid pointer to a `foxglove_channel` created via `foxglove_channel_create`.
 *
 * If the passed channel is null, an invalid id of 0 is returned.
 */
uint64_t foxglove_channel_get_id(const struct foxglove_channel *channel);

/**
 * Log a message on a channel.
 *
 * # Safety
 * `data` must be non-null, and the range `[data, data + data_len)` must contain initialized data
 * contained within a single allocated object.
 *
 * `log_time` may be null or may point to a valid value.
 */
foxglove_error foxglove_channel_log(const struct foxglove_channel *channel,
                                    const uint8_t *data,
                                    size_t data_len,
                                    const uint64_t *log_time);

/**
 * Create a new context. This never fails.
 * You must pass this to `foxglove_context_free` when done with it.
 */
const struct foxglove_context *foxglove_context_new(void);

/**
 * Free a context created via `foxglove_context_new` or `foxglove_context_free`.
 *
 * # Safety
 * `context` must be a valid pointer to a context created via `foxglove_context_new`.
 */
void foxglove_context_free(const struct foxglove_context *context);

/**
 * For use by the C++ SDK. Identifies that wrapper as the source of logs.
 */
void foxglove_internal_register_cpp_wrapper(void);

/**
 * Convert a `FoxgloveError` code to a C string.
 */
const char *foxglove_error_to_cstr(foxglove_error error);

/**
 * Create a new connection graph.
 *
 * The graph must later be freed with `foxglove_connection_graph_free`.
 *
 * # Safety
 * `graph` must be a valid pointer to a pointer to a `foxglove_connection_graph`.
 */
foxglove_error foxglove_connection_graph_create(struct foxglove_connection_graph **graph);

/**
 * Free the connection graph.
 *
 * # Safety
 * `graph` must be a valid pointer to a `foxglove_connection_graph` created by
 * `foxglove_connection_graph_create`.
 */
void foxglove_connection_graph_free(struct foxglove_connection_graph *graph);

/**
 * Set a published topic and its associated publisher ids. Overwrites any existing topic with the
 * same name.
 *
 * # Safety
 * `topic`, and each ID in `publisher_ids` must adhere to the safety rules of `foxglove_string`.
 * `publisher_ids_count` must be the number of elements in the `publisher_ids` array.
 *
 * These strings are copied from the pointers, and need only be valid for the duration of this
 * function call.
 */
foxglove_error foxglove_connection_graph_set_published_topic(struct foxglove_connection_graph *FOXGLOVE_NONNULL graph,
                                                             struct foxglove_string topic,
                                                             const struct foxglove_string *publisher_ids,
                                                             size_t publisher_ids_count);

/**
 * Set a subscribed topic and its associated subscriber ids. Overwrites any existing topic with the
 * same name.
 *
 * # Safety
 * `topic`, and each ID in `subscriber_ids` must adhere to the safety rules of `foxglove_string`.
 * `subscriber_ids_count` must be the number of elements in the `subscriber_ids` array.
 */
foxglove_error foxglove_connection_graph_set_subscribed_topic(struct foxglove_connection_graph *FOXGLOVE_NONNULL graph,
                                                              struct foxglove_string topic,
                                                              const struct foxglove_string *subscriber_ids,
                                                              size_t subscriber_ids_count);

/**
 * Set an advertised service and its associated provider ids. Overwrites any existing service with
 * the same name.
 *
 * # Safety
 * `graph` must be a valid pointer to a `foxglove_connection_graph` created by
 * `foxglove_connection_graph_create`. `service`, and each ID in `provider_ids` must adhere to the
 * safety rules of `FoxgloveString`. `provider_ids_count` must be the number of elements in the
 * `provider_ids` array.
 */
foxglove_error foxglove_connection_graph_set_advertised_service(struct foxglove_connection_graph *FOXGLOVE_NONNULL graph,
                                                                struct foxglove_string service,
                                                                const struct foxglove_string *provider_ids,
                                                                size_t provider_ids_count);

/**
 * Completes a fetch asset request by sending asset data to the client.
 *
 * # Safety
 * - `responder` must be a pointer to a `foxglove_fetch_asset_responder` obtained via the
 *   `foxglove_server_options.fetch_asset` callback. This value is moved into this
 *   function, and must not accessed afterwards.
 * - `data` must be a pointer to the response data. This value is copied by this function.
 */
void foxglove_fetch_asset_respond_ok(struct foxglove_fetch_asset_responder *responder,
                                     struct foxglove_bytes data);

/**
 * Completes a request by sending an error message to the client.
 *
 * # Safety
 * - `responder` must be a pointer to a `foxglove_fetch_asset_responder` obtained via the
 *   `foxglove_server_options.fetch_asset` callback. This value is moved into this
 *   function, and must not accessed afterwards.
 * - `message` must be a pointer to a valid UTF-8 string. This value is copied by this function.
 */
void foxglove_fetch_asset_respond_error(struct foxglove_fetch_asset_responder *responder,
                                        struct foxglove_string message);

/**
 * Initialize SDK logging with the given severity level.
 *
 * The SDK logs informational messages to stderr. Any messages below the given level are not
 * logged.
 *
 * This function should be called before other Foxglove initialization to capture output from all
 * components. Subsequent calls will have no effect.
 *
 * Log level may be overridden with the FOXGLOVE_LOG_LEVEL environment variable: "debug", "info",
 * "warn", "error", or "off". The default level is "info".
 *
 * Log styles (colors) may be configured with the FOXGLOVE_LOG_STYLE environment variable "never",
 * "always", or "auto" (default).
 */
void foxglove_set_log_level(foxglove_log_level level);

/**
 * Creates a new parameter array with the specified capacity.
 *
 * The array must be freed with `foxglove_parameter_array_free`.
 */
struct foxglove_parameter_array *foxglove_parameter_array_create(size_t capacity);

/**
 * Pushes a parameter into the array.
 *
 * # Safety
 * - `array` must be a valid pointer to an array allocated by `foxglove_parameter_array_create`.
 * - `param` must be a valid parameter to a value allocated by `foxglove_parameter_create` or
 *   `foxglove_parameter_clone`. This value is moved into this function, and must not be accessed
 *   afterwards.
 */
foxglove_error foxglove_parameter_array_push(struct foxglove_parameter_array *array,
                                             struct foxglove_parameter *param);

/**
 * Frees the parameter array and its contained parameters.
 *
 * # Safety
 * - `array` must be a valid pointer to a value allocated by `foxglove_parameter_array_create`.
 */
void foxglove_parameter_array_free(struct foxglove_parameter_array *array);

/**
 * Creates a new parameter.
 *
 * The parameter must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 * - `value` must either be a valid pointer to a value allocated by
 *   `foxglove_parameter_value_create`, or NULL. This value is moved into this function, and must
 *   not be accessed afterwards.
 */
foxglove_error foxglove_parameter_create(struct foxglove_parameter **param,
                                         struct foxglove_string name,
                                         foxglove_parameter_type type,
                                         struct foxglove_parameter_value *value);

/**
 * Creates a new empty parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_create_empty(struct foxglove_parameter **param,
                                               struct foxglove_string name);

/**
 * Creates a new number parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_create_float64(struct foxglove_parameter **param,
                                                 struct foxglove_string name,
                                                 double value);

/**
 * Creates a new boolean parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_create_boolean(struct foxglove_parameter **param,
                                                 struct foxglove_string name,
                                                 bool value);

/**
 * Creates a new string parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 * - `value` must be a valid `foxglove_string`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_create_string(struct foxglove_parameter **param,
                                                struct foxglove_string name,
                                                struct foxglove_string value);

/**
 * Creates a new byte array parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 * - `value` must be a valid `foxglove_bytes`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_create_byte_array(struct foxglove_parameter **param,
                                                    struct foxglove_string name,
                                                    struct foxglove_bytes value);

/**
 * Creates a new parameter which is an array of float64 values.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 * - `values` must be a valid pointer to an array of float64 values of `values_len` elements. This
 *   value is copied by this function.
 */
foxglove_error foxglove_parameter_create_float64_array(struct foxglove_parameter **param,
                                                       struct foxglove_string name,
                                                       const double *values,
                                                       size_t values_len);

/**
 * Creates a new parameter which is a dictionary of parameter values.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer.
 * - `name` must be a valid `foxglove_string`. This value is copied by this function.
 * - `dict` must be a valid pointer to a value allocated by
 *   `foxglove_parameter_value_dict_create`. This value is moved into this function, and must not
 *   be accessed afterwards.
 */
foxglove_error foxglove_parameter_create_dict(struct foxglove_parameter **param,
                                              struct foxglove_string name,
                                              struct foxglove_parameter_value_dict *dict);

/**
 * Returns an estimate of the decoded length for the byte array in bytes.
 *
 * # Safety
 * - `param` must be a valid pointer to a value allocated by `foxglove_parameter_create` or
 *   `foxglove_parameter_clone`.
 * - `size` must be a valid pointer.
 */
foxglove_error foxglove_parameter_get_byte_array_decoded_size(const struct foxglove_parameter *param,
                                                              size_t *len);

/**
 * Decodes a byte array into the provided buffer.
 *
 * The buffer should be at least the size returned by
 * `foxglove_parameter_get_byte_array_decoded_size`.
 *
 * On success, updates `len` with the number of bytes written to the provided buffer.
 *
 * # Safety
 * - `param` must be a valid pointer to a value allocated by `foxglove_parameter_create` or
 *   `foxglove_parameter_clone`.
 * - `data` must be a valid pointer to a writable buffer of size `len`.
 * - `len` must be a valid pointer.
 */
foxglove_error foxglove_parameter_decode_byte_array(const struct foxglove_parameter *param,
                                                    uint8_t *data,
                                                    size_t *len);

/**
 * Clones a parameter.
 *
 * The value must be freed with `foxglove_parameter_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_array_push`.
 *
 * # Safety
 * - `param` must be a valid pointer to a value allocated by `foxglove_parameter_create` or
 *   `foxglove_parameter_clone`.
 */
struct foxglove_parameter *foxglove_parameter_clone(const struct foxglove_parameter *param);

/**
 * Frees a parameter.
 *
 * # Safety
 * - `param` must be a valid pointer to a value allocated by `foxglove_parameter_create` or
 *   `foxglove_parameter_clone`.
 */
void foxglove_parameter_free(struct foxglove_parameter *param);

/**
 * Creates a new number parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 */
struct foxglove_parameter_value *foxglove_parameter_value_create_number(double number);

/**
 * Creates a new boolean parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 */
struct foxglove_parameter_value *foxglove_parameter_value_create_boolean(bool boolean);

/**
 * Creates a new string parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 *
 * # Safety
 * - `string` must be a valid `foxglove_string`. This value is copied by this function.
 */
foxglove_error foxglove_parameter_value_create_string(struct foxglove_parameter_value **value,
                                                      struct foxglove_string string);

/**
 * Creates a new array parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 *
 * # Safety
 * - `array` must be a valid pointer to a value allocated by
 *   `foxglove_parameter_value_array_create`. This value is moved into this function, and must not
 *   be accessed afterwards.
 */
struct foxglove_parameter_value *foxglove_parameter_value_create_array(struct foxglove_parameter_value_array *array);

/**
 * Creates a new dict parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 *
 * # Safety
 * - `dict` must be a valid pointer to a value allocated by
 *   `foxglove_parameter_value_dict_create`. This value is moved into this function, and must not be
 *   accessed afterwards.
 */
struct foxglove_parameter_value *foxglove_parameter_value_create_dict(struct foxglove_parameter_value_dict *dict);

/**
 * Clones a parameter value.
 *
 * The value must be freed with `foxglove_parameter_value_free`, or by passing it to a consuming
 * function such as `foxglove_parameter_create`.
 *
 * # Safety
 * - `value` must be a valid pointer to a value allocated by `foxglove_parameter_value_create` or
 *   `foxglove_parameter_value_clone`.
 */
struct foxglove_parameter_value *foxglove_parameter_value_clone(const struct foxglove_parameter_value *value);

/**
 * Frees a parameter value.
 *
 * # Safety
 * - `value` must be a valid pointer to a value allocated by `foxglove_parameter_value_create_*`.
 */
void foxglove_parameter_value_free(struct foxglove_parameter_value *value);

/**
 * Creates a new value array with the specified capacity.
 *
 * The parameter must be freed with `foxglove_parameter_value_array_free`, or by passing it to a
 * consuming function such as `foxglove_parameter_value_create_array`.
 */
struct foxglove_parameter_value_array *foxglove_parameter_value_array_create(size_t capacity);

/**
 * Pushes a parameter value into the array.
 *
 * # Safety
 * - `array` must be a valid pointer to an array allocated by
 *   `foxglove_parameter_value_array_create`.
 * - `value` must be a valid pointer to a value allocated by `foxglove_parameter_value_create_*`.
 *   This value is moved into this function, and must not be accessed afterwards.
 */
foxglove_error foxglove_parameter_value_array_push(struct foxglove_parameter_value_array *array,
                                                   struct foxglove_parameter_value *value);

/**
 * Frees a parameter value array.
 *
 * # Safety
 * - `array` is a valid pointer to a value allocated by `foxglove_parameter_value_array_create`.
 */
void foxglove_parameter_value_array_free(struct foxglove_parameter_value_array *array);

/**
 * Creates a new value dict with the specified capacity.
 *
 * The parameter must be freed with `foxglove_parameter_value_dict_free`, or by passing it to a
 * consuming function such as `foxglove_parameter_value_create_dict`.
 */
struct foxglove_parameter_value_dict *foxglove_parameter_value_dict_create(size_t capacity);

/**
 * Inserts an entry into the parameter value dict.
 *
 * # Safety
 * - `key` must be a valid `foxglove_string`. This value is copied by this function.
 * - `value` must be a valid pointer to a value allocated by `foxglove_parameter_value_create_*`.
 *   This value is moved into this function, and must not be accessed afterwards.
 */
foxglove_error foxglove_parameter_value_dict_insert(struct foxglove_parameter_value_dict *dict,
                                                    struct foxglove_string key,
                                                    struct foxglove_parameter_value *value);

/**
 * Frees a parameter value dict.
 *
 * # Safety
 * - `dict` is a valid pointer to a value allocated by `foxglove_parameter_value_dict_create`.
 */
void foxglove_parameter_value_dict_free(struct foxglove_parameter_value_dict *dict);

/**
 * Creates a new websocket service.
 *
 * The service must be registered with a websocket server using `foxglove_server_add_service`, or
 * freed with `foxglove_service_free`.
 *
 * The callback is invoked from the client's main poll loop and must not block. If blocking or
 * long-running behavior is required, the implementation should return immediately and handle the
 * request asynchronously.
 *
 * The `request` structure provided to the callback is only valid for the duration of the
 * callback. If the implementation wishes to retain its data for a longer lifetime, it must copy
 * data out of it.
 *
 * The `responder` provided to the callback represents an unfulfilled response. The implementation
 * must eventually call either `foxglove_service_respond_ok` or `foxglove_service_respond_error`,
 * exactly once, in order to complete the request. It is safe to invoke these completion functions
 * synchronously from the context of the callback.
 *
 * # Safety
 * - `service` must be a valid pointer.
 * - `name` must be a valid pointer to a UTF-8 string.
 * - `schema` must be NULL, or a valid pointer to a service schema.
 * - `callback` must be a valid pointer to a service callback function, which must remain valid
 *   until the service is either unregistered or freed.
 */
foxglove_error foxglove_service_create(struct foxglove_service **service,
                                       struct foxglove_string name,
                                       const struct foxglove_service_schema *schema,
                                       const void *context,
                                       void (*callback)(const void *context,
                                                        const struct foxglove_service_request *request,
                                                        struct foxglove_service_responder *responder));

/**
 * Frees a service that was never registered to a websocket server.
 *
 * # Safety
 * - `service` must be a valid pointer to a service allocated by `foxglove_service_create`. The
 *   service MUST NOT have been previously registered with a websocket server.
 */
void foxglove_service_free(struct foxglove_service *service);

/**
 * Overrides the default response encoding.
 *
 * # Safety
 * - `responder` must be a pointer to a `foxglove_service_responder` obtained via the
 *   `foxglove_service.handler` callback.
 * - `encoding` must be a pointer to a valid UTF-8 string. This value is copied by this function.
 */
foxglove_error foxglove_service_set_response_encoding(struct foxglove_service_responder *responder,
                                                      struct foxglove_string encoding);

/**
 * Completes a request by sending response data to the client.
 *
 * # Safety
 * - `responder` must be a pointer to a `foxglove_service_responder` obtained via the
 *   `foxglove_service.handler` callback. This value is moved into this function, and must not
 *   accessed afterwards.
 * - `data` must be a pointer to the response data. This value is copied by this function.
 */
void foxglove_service_respond_ok(struct foxglove_service_responder *responder,
                                 struct foxglove_bytes data);

/**
 * Completes a request by sending an error message to the client.
 *
 * # Safety
 * - `responder` must be a pointer to a `foxglove_service_responder` obtained via the
 *   `foxglove_service.handler` callback. This value is moved into this function, and must not
 *   accessed afterwards.
 * - `message` must be a pointer to a valid UTF-8 string. This value is copied by this function.
 */
void foxglove_service_respond_error(struct foxglove_service_responder *responder,
                                    struct foxglove_string message);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* FOXGLOVE_H */
